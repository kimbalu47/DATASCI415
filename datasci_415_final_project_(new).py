# -*- coding: utf-8 -*-
"""datasci 415 FINAL PROJECT (new)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OR1NTfhVk0C89iRp0eGHyitD5OogO97x
"""

!pip install ta

import yfinance as yf
import pandas as pd
import ta
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# nvidia data

nvidia = yf.download('NVDA', start='2023-01-01', end='2023-12-31', interval="1d")
nvidia = nvidia.dropna()

close = nvidia["Close"].squeeze()
high = nvidia["High"].squeeze()
low = nvidia["Low"].squeeze()
volume = nvidia["Volume"].squeeze()

obv = ta.volume.OnBalanceVolumeIndicator(close=close, volume=volume)
nvidia["OBV"] = obv.on_balance_volume()

ad = ta.volume.AccDistIndexIndicator(high=high, low=low, close=close, volume=volume)
nvidia["AD"] = ad.acc_dist_index()

adx = ta.trend.ADXIndicator(high=high, low=low, close=close, window=14)
nvidia["ADX"] = adx.adx()

macd = ta.trend.MACD(close=close)
nvidia["MACD"] = macd.macd()
nvidia["MACD_Signal"] = macd.macd_signal()
nvidia["MACD_Diff"] = macd.macd_diff()

rsi = ta.momentum.RSIIndicator(close=close, window=14)
nvidia["RSI"] = rsi.rsi()

stoch = ta.momentum.StochasticOscillator(high=high, low=low, close=close, window=14, smooth_window=3)
nvidia["Stoch_K"] = stoch.stoch()
nvidia["Stoch_D"] = stoch.stoch_signal()

nvidia = nvidia.replace([np.inf, -np.inf], np.nan)
nvidia = nvidia.dropna()

print(nvidia.head())

# use this data for

close_prices = nvidia['Close']

train_size = int(len(close_prices) * 0.8)

train = close_prices[:train_size]
test = close_prices[train_size:]

exog_train = nvidia[['Open', 'High', 'Low', 'Volume']].iloc[:train_size]
exog_test = nvidia[['Open', 'High', 'Low', 'Volume']].iloc[train_size:]

model = ARIMA(train, order=(5, 1, 0), exog=exog_train)
model_fit = model.fit()

print(model_fit.summary())

forecast = model_fit.forecast(steps=len(test), exog=exog_test)

plt.figure(figsize=(10, 6))
plt.plot(train, label='Training Data')
plt.plot(test.index, test, label='Actual Prices', color='blue')
plt.plot(test.index, forecast, label='Forecasted Prices', color='red')
plt.legend()
plt.title('ARIMA Model with Historical Data')
plt.show()

"""Historical data and market sentiment"""

# Preparing data for training and testing
close_prices = nvidia['Close']
train_size = int(len(close_prices) * 0.8)
train = close_prices[:train_size]
test = close_prices[train_size:]

# Including all technical indicators as exogenous variables
exog_vars = nvidia[['Open', 'High', 'Low', 'Volume', 'OBV', 'AD', 'ADX', 'MACD', 'MACD_Signal', 'MACD_Diff', 'RSI', 'Stoch_K', 'Stoch_D']]
exog_train = exog_vars.iloc[:train_size]
exog_test = exog_vars.iloc[train_size:]

# ARIMA model with exogenous variables
model = ARIMA(train, order=(5, 1, 0), exog=exog_train)
model_fit = model.fit()

print(model_fit.summary())

# Forecasting
forecast = model_fit.forecast(steps=len(test), exog=exog_test)

# Plotting the results
plt.figure(figsize=(10, 6))
plt.plot(train, label='Training Data')
plt.plot(test.index, test, label='Actual Prices', color='blue')
plt.plot(test.index, forecast, label='Forecasted Prices', color='red')
plt.legend()
plt.title('ARIMA Model with Exogenous Variables Forecast')
plt.show()

"""LSTM with historical data only"""

# Download historical stock data for NVDA
nvda_data = yf.download('NVDA', start='2010-01-01', end='2024-11-16')

# Use 'Close' prices for prediction
data = nvda_data[['Close', 'High', 'Low', 'Volume']]

# Normalize the data using MinMaxScaler (scales data between 0 and 1)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Define function to create sequences of data
def create_sequences(data, time_step=60):
    X, y = [], []
    for i in range(time_step, len(data)):
        X.append(data[i-time_step:i, 0])  # Use past 'time_step' days as features
        y.append(data[i, 0])  # Predict the 'Close' price of the next day
    return np.array(X), np.array(y)

# Create sequences for the data
time_step = 60  # Use the past 60 days to predict the next day's price
X, y = create_sequences(scaled_data, time_step)

# Split the data into training and testing sets (80/20 split)
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# Reshape data for LSTM (LSTM expects 3D input: [samples, time steps, features])
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

# Define the LSTM model
model = Sequential()

# Add the LSTM layer (units can be tuned)
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(Dropout(0.2))  # Dropout for regularization
model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(units=1))  # Output layer (predict next day's 'Close' price)

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=10, batch_size=32)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Inverse transform the predictions and true values to get actual price
y_pred_actual = scaler.inverse_transform(y_pred)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

# Evaluate the model performance
mae = mean_absolute_error(y_test_actual, y_pred_actual)
mse = mean_squared_error(y_test_actual, y_pred_actual)
print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")

# Plot the results
plt.figure(figsize=(10, 6))
plt.plot(nvda_data.index[train_size + time_step:], y_test_actual, label='Actual Prices', color='blue')
plt.plot(nvda_data.index[train_size + time_step:], y_pred_actual, label='Predicted Prices (LSTM)', color='red')
plt.legend()
plt.title('LSTM Predictions vs Actual Prices')
plt.show()

"""LSTM with historical data and market sentiment data"""

# Use 'Close' prices and technical indicators for prediction
data = nvda_data[['Close', 'OBV', 'AD', 'ADX', 'MACD', 'MACD_Signal', 'MACD_Diff', 'RSI', 'Stoch_K', 'Stoch_D']]

# Normalize the data using MinMaxScaler (scales data between 0 and 1)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Define function to create sequences of data
def create_sequences(data, time_step=60):
    X, y = [], []
    for i in range(time_step, len(data)):
        X.append(data[i-time_step:i])  # Use past 'time_step' days as features
        y.append(data[i, 0])  # Predict the 'Close' price of the next day
    return np.array(X), np.array(y)

# Create sequences for the data
time_step = 60  # Use the past 60 days to predict the next day's price
X, y = create_sequences(scaled_data, time_step)

# Split the data into training and testing sets (80/20 split)
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# Reshape data for LSTM (LSTM expects 3D input: [samples, time steps, features])
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], X_train.shape[2])
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], X_test.shape[2])

# Define the LSTM model
model = Sequential()

# Add the LSTM layer (units can be tuned)
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dropout(0.2))  # Dropout for regularization
model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(units=1))  # Output layer (predict next day's 'Close' price)

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=10, batch_size=32)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Inverse transform the predictions and true values to get actual price
y_pred_actual = scaler.inverse_transform(np.hstack((y_pred, np.zeros((y_pred.shape[0], scaled_data.shape[1]-1)))))
y_test_actual = scaler.inverse_transform(np.hstack((y_test.reshape(-1, 1), np.zeros((y_test.shape[0], scaled_data.shape[1]-1)))))

# Evaluate the model performance
mae = mean_absolute_error(y_test_actual[:, 0], y_pred_actual[:, 0])
mse = mean_squared_error(y_test_actual[:, 0], y_pred_actual[:, 0])
print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")

# Plot the results
plt.figure(figsize=(10, 6))
plt.plot(nvda_data.index[train_size + time_step:], y_test_actual[:, 0], label='Actual Prices', color='blue')
plt.plot(nvda_data.index[train_size + time_step:], y_pred_actual[:, 0], label='Predicted Prices (LSTM)', color='red')
plt.legend()
plt.title('LSTM Predictions vs Actual Prices')
plt.show()