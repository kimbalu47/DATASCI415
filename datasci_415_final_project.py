# -*- coding: utf-8 -*-
"""datasci 415 FINAL PROJECT

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OR1NTfhVk0C89iRp0eGHyitD5OogO97x
"""

!pip install ta

import yfinance as yf
import pandas as pd
import ta  # For technical indicators

# Fetch NVIDIA stock data
ticker = "NVDA"
data = yf.download(ticker, start="2023-01-01", end="2023-12-31", interval="1d")

# Ensure data is properly formatted
data = data.dropna()

# Squeeze DataFrame columns to ensure they're one-dimensional
close_prices = data["Close"].squeeze()
high_prices = data["High"].squeeze()
low_prices = data["Low"].squeeze()
volume = data["Volume"].squeeze()

# Add OBV (On-Balance Volume)
obv_indicator = ta.volume.OnBalanceVolumeIndicator(close=close_prices, volume=volume)
data["OBV"] = obv_indicator.on_balance_volume()

# Add AD (Accumulation/Distribution Line)
ad_indicator = ta.volume.AccDistIndexIndicator(high=high_prices, low=low_prices, close=close_prices, volume=volume)
data["AD"] = ad_indicator.acc_dist_index()

# Add ADX (Average Directional Index)
adx_indicator = ta.trend.ADXIndicator(high=high_prices, low=low_prices, close=close_prices, window=14)
data["ADX"] = adx_indicator.adx()

# Add MACD (Moving Average Convergence Divergence)
macd_indicator = ta.trend.MACD(close=close_prices)
data["MACD"] = macd_indicator.macd()
data["MACD_Signal"] = macd_indicator.macd_signal()
data["MACD_Diff"] = macd_indicator.macd_diff()

# Add RSI (Relative Strength Index)
rsi_indicator = ta.momentum.RSIIndicator(close=close_prices, window=14)
data["RSI"] = rsi_indicator.rsi()

# Add Stochastic Oscillator (Stoch)
stoch_indicator = ta.momentum.StochasticOscillator(high=high_prices, low=low_prices, close=close_prices, window=14, smooth_window=3)
data["Stoch_K"] = stoch_indicator.stoch()
data["Stoch_D"] = stoch_indicator.stoch_signal()

# Print the processed data
print(data.tail())

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller

# Download historical data for NVDA
nvda_data = yf.download('NVDA', start='2023-01-01', end='2023-12-31')

# Use the 'Close' column for prediction
close_prices = nvda_data['Close']

# Test for stationarity (ADF Test)
def test_stationarity(series):
    result = adfuller(series)
    print(f"ADF Statistic: {result[0]}")
    print(f"p-value: {result[1]}")
    if result[1] < 0.05:
        print("Data is stationary")
    else:
        print("Data is not stationary")

test_stationarity(close_prices)

# Differencing if the data is not stationary
close_prices_diff = close_prices.diff().dropna()

# Split the data into training and testing datasets (80/20 split)
train_size = int(len(close_prices) * 0.8)
train_data, test_data = close_prices[:train_size], close_prices[train_size:]

# Use 'Open', 'High', 'Low', 'Volume' as exogenous variables
exog_train = nvda_data[['Open', 'High', 'Low', 'Volume']].iloc[:train_size]
exog_test = nvda_data[['Open', 'High', 'Low', 'Volume']].iloc[train_size:]

# Fit the ARIMA model with exogenous variables (External regressors)
model = ARIMA(train_data, order=(5, 1, 0), exog=exog_train)
model_fit = model.fit()

# Print model summary
print(model_fit.summary())

# Make forecast with the test data (including exogenous variables for the forecast period)
forecast = model_fit.forecast(steps=len(test_data), exog=exog_test)

# Plotting the forecast vs actual
plt.figure(figsize=(10, 6))
plt.plot(train_data, label='Training Data')
plt.plot(test_data.index, test_data, label='Actual Prices', color='blue')
plt.plot(test_data.index, forecast, label='Forecasted Prices', color='red')
plt.legend()
plt.title('ARIMA Model with Exogenous Variables Forecast')
plt.show()

import yfinance as yf
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Download historical stock data for NVDA
nvda_data = yf.download('NVDA', start='2010-01-01', end='2024-11-16')

# Use 'Close' prices for prediction
data = nvda_data[['Close']]

# Normalize the data using MinMaxScaler (scales data between 0 and 1)
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data)

# Define function to create sequences of data
def create_sequences(data, time_step=60):
    X, y = [], []
    for i in range(time_step, len(data)):
        X.append(data[i-time_step:i, 0])  # Use past 'time_step' days as features
        y.append(data[i, 0])  # Predict the 'Close' price of the next day
    return np.array(X), np.array(y)

# Create sequences for the data
time_step = 60  # Use the past 60 days to predict the next day's price
X, y = create_sequences(scaled_data, time_step)

# Split the data into training and testing sets (80/20 split)
train_size = int(len(X) * 0.8)
X_train, X_test = X[:train_size], X[train_size:]
y_train, y_test = y[:train_size], y[train_size:]

# Reshape data for LSTM (LSTM expects 3D input: [samples, time steps, features])
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)
X_test = X_test.reshape(X_test.shape[0], X_test.shape[1], 1)

# Define the LSTM model
model = Sequential()

# Add the LSTM layer (units can be tuned)
model.add(LSTM(units=50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
model.add(Dropout(0.2))  # Dropout for regularization
model.add(LSTM(units=50, return_sequences=False))
model.add(Dropout(0.2))
model.add(Dense(units=1))  # Output layer (predict next day's 'Close' price)

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Train the model
model.fit(X_train, y_train, epochs=10, batch_size=32)

# Make predictions on the test set
y_pred = model.predict(X_test)

# Inverse transform the predictions and true values to get actual price
y_pred_actual = scaler.inverse_transform(y_pred)
y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))

# Evaluate the model performance
mae = mean_absolute_error(y_test_actual, y_pred_actual)
mse = mean_squared_error(y_test_actual, y_pred_actual)
print(f"Mean Absolute Error: {mae}")
print(f"Mean Squared Error: {mse}")

# Plot the results
plt.figure(figsize=(10, 6))
plt.plot(nvda_data.index[train_size + time_step:], y_test_actual, label='Actual Prices', color='blue')
plt.plot(nvda_data.index[train_size + time_step:], y_pred_actual, label='Predicted Prices (LSTM)', color='red')
plt.legend()
plt.title('LSTM Predictions vs Actual Prices')
plt.show()